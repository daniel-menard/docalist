<?php


class oldqp
{
    const
      TOK_END=-1,
      TOK_ERROR=0,
      TOK_BLANK=1,

      TOK_AND=10,
      TOK_OR=11,
      TOK_AND_NOT=12,
      TOK_XOR=13,

      TOK_NEAR=20,
      TOK_ADJ=21,

      TOK_LOVE=30,
      TOK_HATE=31,

      TOK_INDEX_NAME=40,

      TOK_TERM=41,
      TOK_WILD_TERM=42,
      TOK_PHRASE_TERM=43,
      TOK_PHRASE_WILD_TERM=44,
      TOK_MATCH_ALL=45,

      TOK_START_PARENTHESE=50,
      TOK_END_PARENTHESE=51,

      TOK_RANGE_START=60,
      TOK_RANGE_END=61
      ;

    private $id, $token;

    /**
     * Analyseur lexical des équations de recherche : retourne le prochaine token
     * de l'équation analysée.
     *
     * Lors du premier appel, read() doit être appellée avec l'équation à analyser. Les
     * appels successifs se font sans passer aucun paramètre.
     *
     * En sortie, read() intialise deux propriétés :
     * - id : le type du token reconnu (l'une des constantes self::TOK_*)
     * - token : le token lu
     *
     * @param string $text l'équation de recherche à analyser
     * @return int l'id obtenu (également stocké dans $this->id)
     */
    private function read($text=null)
    {
        // Les mots reconnus comme opérateur et le token correspondant
        static $opValue=array
        (
            'et'=>self::TOK_AND,
            'ou'=>self::TOK_OR,
            'sauf'=>self::TOK_AND_NOT,

            'and'=>self::TOK_AND,
            'or'=>self::TOK_OR,
            'not'=>self::TOK_AND_NOT,
            'but'=>self::TOK_AND_NOT, // ancien bis

            'xor'=>self::TOK_XOR,
            'near'=>self::TOK_NEAR,
            'adj'=>self::TOK_ADJ
        );

        // L'équation de recherche en cours d'analyse
        static $equation;

        // La position du caractère en cours au sein de $equation
        static $i;

        // Un flag qui indique si on est au sein d'une expression entre guillemets ou non
        static $inString;

        // Initialisation si on nous passe une nouvelle équation à parser
        if (!is_null($text))
        {
            $equation=$text;
            $equation=str_replace(array('[',']'), array('"@break ', ' @break"'), $equation);
            $equation=Utils::convertString($equation, 'queryparser');
            $equation=trim($equation) . '¤';

            $i=0;
            $inString=false;
        }
        elseif(is_null($equation))
            throw new Exception('lexer non initialisé');

        // Extrait le prochain token
        for(;;)
        {
            // Passe les blancs
            while($equation[$i]===' ') ++$i;

            switch($this->token=$equation[$i])
            {
                case '¤':       return $this->id=self::TOK_END;
                case '+': ++$i; return $this->id=self::TOK_LOVE;
                case '-': ++$i; return $this->id=self::TOK_HATE;
                case '(': ++$i; return $this->id=self::TOK_START_PARENTHESE;
                case ')': ++$i; return $this->id=self::TOK_END_PARENTHESE;
                case '*': ++$i; return $this->id=self::TOK_MATCH_ALL;
                case ':':
                case '=': ++$i; return $this->id=self::TOK_ERROR;
                case '"':
                    ++$i;
                    $inString=!$inString;

                    // Fin de la chaine en cours : retourne un blanc (sinon "a b" "c d" est interprété comme "a b c d")
                    if (!$inString)
                        return $this->id=self::TOK_BLANK;

                    // Début d'une chaine : ignore les caractères spéciaux et retourne le premier mot
                    if (false===$pt=strpos($equation, '"', $i))
                        throw new Exception('guillemet fermant non trouvé');
                    $len=$pt-$i;
                    $string=strtr(substr($equation, $i, $len), '+-():=[]', '       ');
                    $equation=substr_replace($equation, $string, $i, $len);
                    return $this->read();

                default:
                    $len=1+strspn($equation, 'abcdefghijklmnopqrstuvwxyz0123456789', $i+1);
                    $this->token=substr($equation, $i, $len);
                    $i+=$len;

                    // Un mot avec troncature à droite ?
                    if ($equation[$i]==='*')
                    {
                        ++$i;
                        return $this->id=($inString ? self::TOK_PHRASE_WILD_TERM : self::TOK_WILD_TERM);
                    }

                    // Un mot dans une phrase
                    if ($inString) return $this->id=self::TOK_PHRASE_TERM;

                    // Un opérateur ?
                    if (isset($opValue[$this->token]))
                        return $this->id=$opValue[$this->token];

                    // Un nom d'index ?
                    while($equation[$i]===' ') ++$i; // Passe les blancs
                    if ($equation[$i]===':' || $equation[$i]==='=' )
                    {
                        ++$i;
                        return $this->id=self::TOK_INDEX_NAME;
                    }

                    // Juste un mot
                    return $this->id=self::TOK_TERM;
            }
        }
    }

    private $prefix;

    public function parseQuery($equation)
    {
        // Initialise le lexer
        $this->read($equation);

        // Préfixe par défaut
        $this->prefix='';

        // Analyse l'équation
        $query=$this->parseExpression();

        // Vérifie qu'on a tout lu
        if ($this->id !== self::TOK_END)
            echo "L'EQUATION N'A PAS ETE ANALYSEE COMPLETEMENT <br />";
        // Retourne la requête
        return $query;
    }

    private function parseExpression()
    {
        $query=null;
        $loveQuery=null;
        $hateQuery=null;
        for(;;)
        {
            switch($this->id)
            {
                case self::TOK_BLANK:
                    $this->read();
                    break;
                case self::TOK_TERM:
                case self::TOK_WILD_TERM:
                case self::TOK_PHRASE_TERM:
                case self::TOK_PHRASE_WILD_TERM:
                case self::TOK_INDEX_NAME:
                    if (is_null($query))
                        $query=$this->parseOr();
                    else
                        $query=new XapianQuery(XapianQuery::OP_OR, $query, $this->parseOr());
                    break;

                case self::TOK_LOVE:
                    $this->read();
                    if (is_null($loveQuery))
                        $loveQuery=$this->parseOr();
                    else
                        $loveQuery=new XapianQuery(XapianQuery::OP_AND, $loveQuery, $this->parseOr());
                    break;

                case self::TOK_HATE:
                    $this->read();
                    if (is_null($hateQuery))
                        $hateQuery=$this->parseOr();
                    else
                        $hateQuery=new XapianQuery(XapianQuery::OP_OR, $hateQuery, $this->parseOr());
                    break;

                case self::TOK_START_PARENTHESE:
                    if (is_null($query))
                        $query=$this->parseCompound();
                    else
                        $query=new XapianQuery(XapianQuery::OP_OR, $query, $this->parseCompound());
                    break;

                case self::TOK_END:
                case self::TOK_END_PARENTHESE:
                    break 2;

                case self::TOK_MATCH_ALL:
                    $query=$this->parseCompound();
                    break;

                default:
                    echo 'inconnu2 : ', 'id=', $this->id, ', token=', $this->token;
                    return;
            }
        }
        if (is_null($query))
        {
            $query=$loveQuery;
            if (!is_null($hateQuery)) $query=new XapianQuery(XapianQuery::OP_AND_NOT, $query, $hateQuery);
        }
        elseif (! is_null($loveQuery))
        {
            $query=new XapianQuery(XapianQuery::OP_AND_MAYBE, $loveQuery, $query);
            if (!is_null($hateQuery)) $query=new XapianQuery(XapianQuery::OP_AND_NOT, $query, $hateQuery);
        }
        else
        {
            if (!is_null($hateQuery)) $query=new XapianQuery(XapianQuery::OP_AND_NOT, $query, $hateQuery);
        }
        return $query;
    }

    private function parseCompound()
    {
        switch($this->id)
        {
            case self::TOK_WILD_TERM:
            case self::TOK_TERM:
                $term=$this->token;

                $terms=array();
                if($this->id===self::TOK_WILD_TERM)
                    $terms=array_merge($terms, $this->expandTerm($term, $this->prefix));
                else
                {
//                  if (false)
                    {
                        if
                        (
                                isset($this->structure['stopwords'][$term])
                            ||
                                strlen($term)<3 && !ctype_digit($term)
                        )
                        {
                            $query=new XapianQuery(); // TODO: à revoir. retourner une MATCH_ALL ou une MATCH_NOTHING ?
                            $this->read();
                            break;
                        }
                    }
                    foreach((array)$this->prefix as $prefix)
                        $terms[]=$prefix.$term;

                }
                $this->read();

                $query=new XapianQuery(XapianQuery::OP_OR, $terms); // TODO: OP_OR=default operator, à mettre en config
                break;

            case self::TOK_INDEX_NAME:

                // Sauvegarde le préfixe actuel
                $save=$this->prefix;

                // Vérifie que ce nom d'index existe et récupère le(s) préfixe(s) associé(s)
                $index=$this->token;
                if (! isset($this->structure['index'][$index]))
                    throw new Exception("Impossible d'interroger sur le champ '$index' : index inconnu");

                $this->prefix=$this->structure['index'][$index];

                // Analyse l'expression qui suit
                $this->read();
                $query=$this->parseCompound();

                // Restaure le préfixe précédent
                $this->prefix=$save;
                break;

            case self::TOK_START_PARENTHESE:
                $this->read();
                $query=$this->parseExpression();
                if ($this->id !== self::TOK_END_PARENTHESE)
                    throw new Exception($this->token.'Parenthèse fermante attendue');
                $this->read();
                break;


            case self::TOK_PHRASE_WILD_TERM:
                $nbWild=1;
            case self::TOK_PHRASE_TERM:
                $nbWild=0;

                $terms=array();
                $type=array();
                do
                {
                    $terms[]=$this->token;
                    $type[]=$this->id;
                    $this->read();
                }
                while($this->id===self::TOK_PHRASE_TERM || ($this->id===self::TOK_PHRASE_WILD_TERM && (++$nbWild)));
                if ($this->id===self::TOK_BLANK) $this->read();

                // Limitation actuelle de xapian : on ne peut avoir qu'une seule troncature dans une expression
//                if($nbWild>1)
//                    throw new exception("$nbWild xxxLa troncature ne peut être utilisé qu'une seule fois dans une expression entre guillemets");
                if($nbWild>1)                   // TODO: mettre en option ?
                    $op=XapianQuery::OP_AND;    // plusieurs troncatures : la phrase devient un "et"
                else
                    $op=XapianQuery::OP_PHRASE;


                // on a des préfixes en cours : p1,p2,p3
                //    -> requête de la forme "term1 term2 term3"
                // on aura autant de phrases qu'on a de préfixes :
                //    -> phrase1 OU phrase 2 OU phrase3
                $phrases=array();
                // (sauf si la requête contient un terme avec troncature et que expand ne retourne rien pour ce préfixe)

                // chaque phrase contient tous les termes
                //    -> (p1:term1 PHRASE p1:term2) OU (p2:term1 PHRASE p2:term2) OU (p3:term1 PHRASE p3:term2)
                $phrase=array();
                foreach((array)$this->prefix as $prefix)
                {
                    foreach($terms as $i=>$term)
                    {
                        if ($type[$i]===self::TOK_PHRASE_TERM)
                        {
                            $phrase[$i]=$prefix.$term;
                        }
                        else
                        {
                            // Génère toutes les possibilités
                            $t=$this->expandTerm($term, $prefix);

                            // Aucun résultat : la phrase ne peut pas aboutir
                            if (count($t)===0) continue 2; // 2=continuer avec le prochain préfixe

                            $phrase[$i]=new XapianQuery(XapianQuery::OP_OR, $t);
                        }
                    }

                    // Fait une phrase avec le tableau phrase obtenu
                    $phrases[]=$p=new XapianQuery($op, $phrase); // TODO: 3=window size du PHRASE, à mettre en config
                }

                // COmbine toutes les phrases en ou
                $query=new XapianQuery(XapianQuery::OP_OR, $phrases);
                break;

            case self::TOK_MATCH_ALL:
                $this->read();
                if ($this->prefix==='')
                    $query=new XapianQuery('');// la syntaxe spéciale de xapian pour désigner [match anything]
                else
                {
                    $t=$this->expandTerm('@has', $this->prefix);
                    if (count($t)===0) // aucun des chaps interrogés n'est "comptable", transforme en requete 'toutes les notices'
                        $query=new XapianQuery(''); // syntaxe spéciale de xapian : match all
                    else
                        $query=new XapianQuery(XapianQuery::OP_OR, $t);
                }
                break;

            default:
                die('truc inattendu : '.$this->id);
        }
        return $query;
    }


    private function parseOr()
    {
        $query=$this->parseAnd();
        while ($this->id===self::TOK_OR)
        {
            $this->read();
            $query=new XapianQuery(XapianQuery::OP_OR, $query, $this->parseExpression()); //parseAnd
        }
        return $query;
    }

    private function parseAnd()
    {
        $query=$this->parseAndNot();
        while ($this->id===self::TOK_AND)
        {
            $this->read();
            $query=new XapianQuery(XapianQuery::OP_AND, $query, $this->parseAndNot());//parseAndNot
        }
        return $query;
    }

    private function parseAndNot()
    {
        $query=$this->parseNear();
        while ($this->id===self::TOK_AND_NOT)
        {
            $this->read();
            $query=new XapianQuery(XapianQuery::OP_AND_NOT, $query, $this->parseNear());
        }
        return $query;
    }

    private function parseNear()
    {
        $query=$this->parseAdj();
        while ($this->id===self::TOK_NEAR)
        {
            $this->read();
            $query=new XapianQuery(XapianQuery::OP_NEAR, array($query, $this->parseAdj()), 5); // TODO: 5=window size du near, à mettre en config
        }
        return $query;
    }

    private function parseAdj()
    {
        $query=$this->parseCompound();
        while ($this->id===self::TOK_ADJ)
        {
            $this->read();
            $query=new XapianQuery(XapianQuery::OP_PHRASE, array($query, $this->parseCompound()), 1); // TODO: 1=window size du ADJ, à mettre en config
        }
        return $query;
    }

    /**
     * @param mixed $prefix préfixe ou tableau de préfixes
     */
    private function expandTerm($term, $prefix='')
    {
        $max=100; // TODO: option de XapianDatabase ou bien dans la config

        $begin=$this->xapianDatabase->allterms_begin();
        $end=$this->xapianDatabase->allterms_end();

        $terms=array();
        $nb=0;
        foreach((array)$prefix as $prefix)
        {
            $prefixTerm=$prefix.$term;
            $begin->skip_to($prefixTerm);
            while (!$begin->equals($end))
            {
                $h=$begin->get_term();
                if (substr($h, 0, strlen($prefixTerm))!==$prefixTerm)
                    break;

                $terms[]=$h;
                if (++$nb>$max)
                    throw new Exception("Le terme '$term*' génère trop de possibilités, augmentez la longueur du préfixe");
                $begin->next();
            }
        }
        return $terms;
    }

    private function dumpEquationTokens($equation)
    {
        $tokenName=array
        (
              self::TOK_END=>'TOK_END',
              self::TOK_ERROR=>'TOK_ERROR',
              self::TOK_BLANK=>'TOK_BLANK',

              self::TOK_AND=>'TOK_AND',
              self::TOK_OR=>'TOK_OR',
              self::TOK_AND_NOT=>'TOK_AND_NOT',
              self::TOK_XOR=>'TOK_XOR',

              self::TOK_NEAR=>'TOK_NEAR',
              self::TOK_ADJ=>'TOK_ADJ',

              self::TOK_LOVE=>'TOK_LOVE',
              self::TOK_HATE=>'TOK_HATE',

              self::TOK_INDEX_NAME=>'TOK_INDEX_NAME',

              self::TOK_TERM=>'TOK_TERM',
              self::TOK_WILD_TERM=>'TOK_WILD_TERM',
              self::TOK_PHRASE_TERM=>'TOK_PHRASE_TERM',
              self::TOK_PHRASE_WILD_TERM=>'TOK_PHRASE_WILD_TERM',
              self::TOK_MATCH_ALL=>'TOK_MATCH_ALL',

              self::TOK_START_PARENTHESE=>'TOK_START_PARENTHESE',
              self::TOK_END_PARENTHESE=>'TOK_END_PARENTHESE',

              self::TOK_RANGE_START=>'TOK_RANGE_START',
              self::TOK_RANGE_END=>'TOK_RANGE_END'
        );

        $query=null;

        while(ob_get_level()) ob_end_flush();
        $t=$this->read($equation);
        $nb=0;
        while($t > 0)
        {
            echo '<code>',$t,':', $tokenName[$t], ' : [', $this->token, ']</code><br />';
            flush();
            $t=$this->read();
            if ($nb++>100) break;
        }
        echo '<code>', $tokenName[$t], ' : [', $this->token, ']</code><br />';
    }
}
